<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>customdataclass API documentation</title>
<meta name="description" content="This module contains a custom dataclass object …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>customdataclass</code></h1>
</header>
<section id="section-intro">
<p>This module contains a custom dataclass object.</p>
<p>It does work kinda good.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module contains a custom dataclass object.

It does work kinda good.
&#34;&#34;&#34;

from __future__ import annotations

import importlib
from typing import Any


class Dataclass:
    &#34;&#34;&#34;Custom dataclass.

    The real reason is that I didn&#39;t really like the way dataclasses work,
    and I wanted to have a better control over the attributes.

    Instead of using the decorator, the a Dataclass must be initialized
    by inheriting from it and specifying the attributes in the class definition.

    This simplifies the code, allowing a better control over the attributes
    and the methods.

    Check the examples folder for more information.

    Initialization parameters:
        enforce_types (bool, optional): If True, the types of the attributes \
            are enforced. Defaults to True.
        frozen (bool, optional): If True, attributes cannot be changed after \
            initialization. Defaults to True
        partial (bool, optional): If True, parameters can be missing in the \
            initialization. Defaults to False.
    &#34;&#34;&#34;

    _frozen: bool = False
    _frozen_after_init: bool = True
    _enforce_types: bool = True
    _partial = False
    _deserialized: bool = False
    _serializer: __module__ = None

    def __init__(self, **kwargs) -&gt; Dataclass:
        &#34;&#34;&#34;Create a new Dataclass.

        Raises:
            AttributeError: an invalid attribute is passed
            AttributeError: an attribute is missing in kwargs.
            TypeError: a value is not of the correct type.
        &#34;&#34;&#34;
        if not kwargs:
            return

        # unfreeze the class for the initialisation
        self._frozen = False

        # check if all the attributes are valid
        self._checkAttributesValid(kwargs)

        if not self._partial:
            # fix the default values
            self._fixDefaultValues(kwargs)
            # check if all the attributes are present
            self._checkAttributesPresent(kwargs)

        # fix the types
        self._fixMissingTypes()

        for k, v in self.__class_attributes__.items():
            # skip the loop if partial is True and the attribute is not present
            if self._enforce_types and not (self._partial and k not in kwargs):
                # serialized format don&#39;t support tuple and set (they convert \
                # both to list), so we need to convert them back IMPLICITLY
                if self._checkDeserializedIterator(kwargs[k], v):
                    if self._deserialized:
                        # convert to tuple or set
                        kwargs[k] = v(kwargs[k])

                # serialised format don&#39;t support classes (they convert them to \
                # dict), so we need to convert them back IMPLICITLY
                if self._checkDeserializedClass(kwargs[k], v):
                    # convert to class
                    if self._deserialized:
                        # convert to class
                        kwargs[k] = v.from_dict(kwargs[k])

                # check that the type is correct
                if not self._checkTypeCorrect(kwargs[k], v):
                    raise TypeError(f&#34;{k} should be {v}, not {type(kwargs[k])}&#34;)

            setattr(self, k, kwargs.get(k, None))

        # freeze the class
        self._frozen = self._frozen_after_init
        # unset the deserialized flag
        self._deserialized = False

    def _checkAttributesValid(self, kwargs: dict) -&gt; bool:
        &#34;&#34;&#34;Check if all the attributes are valid (as specified in the class \
            definition).

        Args:
            kwargs (dict): kwargs to check

        Returns:
            bool: True if all the attributes are valid, False otherwise.
        &#34;&#34;&#34;
        for k in kwargs.keys():
            if k not in self.__class_attributes__.keys():
                raise AttributeError(f&#34;{k} is not a valid attribute&#34;)

        return True

    def _fixDefaultValues(self, kwargs: dict) -&gt; None:
        &#34;&#34;&#34;Fix the default values.

        Args:
            kwargs (dict): kwargs to check
        &#34;&#34;&#34;
        for k in self.__class_attributes__:
            if k not in kwargs:
                kwargs[k] = self.__getattribute__(k)

    def _checkAttributesPresent(self, kwargs: dict) -&gt; bool:
        &#34;&#34;&#34;Check if all the attributes are present (as specified in the class \
            definition).

        Args:
            kwargs (dict): kwargs to check

        Returns:
            bool: True if all the attributes are present, False otherwise.
        &#34;&#34;&#34;
        for k in self.__class_attributes__.keys():
            if k not in kwargs:
                raise AttributeError(f&#34;Missing {k} in kwargs&#34;)

        return True

    def _fixMissingTypes(self) -&gt; None:
        &#34;&#34;&#34;Fix the missing types.&#34;&#34;&#34;
        for k, v in self.__class_attributes__.items():
            if v is None:
                # no type has been specified
                self.__class__.__annotations__[k] = Any

    def _checkTypeCorrect(self, value: Any, valid_type: type) -&gt; bool:
        &#34;&#34;&#34;Check if the type of the value is correct.

        Args:
            value (Any): value to check
            valid_type (type): type of the value

        Returns:
            bool: True if the type is correct, False otherwise.
        &#34;&#34;&#34;
        if valid_type in (Any, None):
            return True

        return isinstance(value, valid_type)

    def _checkDeserializedIterator(self, value: list[Any], valid_type: type) -&gt; bool:
        &#34;&#34;&#34;Check if the value is a valid iterator.

        Args:
            value (list[Any]): value to check
            valid_type (type): type of the value

        Returns:
            bool: True if the value is valid, False otherwise.
        &#34;&#34;&#34;
        if not isinstance(value, list):
            return False

        return valid_type in (set, tuple)

    def _checkDeserializedClass(self, value: dict, valid_type: type) -&gt; bool:
        &#34;&#34;&#34;Check if the value is a valid class.

        Args:
            value (dict): value to check
            valid_type (type): type of the value

        Returns:
            bool: True if the value is valid, False otherwise.
        &#34;&#34;&#34;
        if not isinstance(value, dict):
            return False

        return issubclass(valid_type, Dataclass)

    def __init_subclass__(
        cls,
        enforce_types: bool = True,
        frozen: bool = True,
        partial: bool = False,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the subclass.

        Args:
            enforce_types (bool, optional): If True, the types of the attributes \
                are enforced.
            frozen (bool, optional): If True, attributes cannot be changed after \
                initialization. Defaults to True.
            partial (bool, optional): If True, the class can be initialized with \
                missing attributes. Defaults to False.
        &#34;&#34;&#34;
        cls._enforce_types = enforce_types
        cls._frozen_after_init = frozen
        cls._partial = partial
        super().__init_subclass__(**kwargs)

    def __setattr__(self, key: str, value):
        &#34;&#34;&#34;Set an attribute.

        Args:
            key (str): name of the attribute
            value (any): value of the attribute

        Raises:
            AttributeError: Attribute is not valid
        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;):
            super().__setattr__(key, value)
            return

        if self._frozen:
            raise AttributeError(
                f&#34;Can&#39;t set {key}. {self.__class__.__name__} is immutable.&#34;
            )

        super().__setattr__(key, value)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        if not self.__clean_dict__:
            return f&#34;{self.__class__.__name__}()&#34;

        parentheses = {
            &#34;tuple&#34;: (&#34;(&#34;, &#34;)&#34;),
            &#34;list&#34;: (&#34;[&#34;, &#34;]&#34;),
            &#34;set&#34;: (&#34;{&#34;, &#34;}&#34;),
            &#34;dict&#34;: (&#34;{&#34;, &#34;}&#34;),
        }

        s = f&#34;{self.__class__.__name__}(&#34;

        for k, v in self.__clean_dict__.items():
            if self._partial and v is None:
                continue
            s += f&#34;{k}=&#34;
            if isinstance(v, str):
                s += f&#39;&#34;{v}&#34;&#39;
            elif isinstance(v, (list, tuple, set, dict)):
                s += parentheses[v.__class__.__name__][0]
                if isinstance(v, dict):
                    s += &#34;, &#34;.join(f&#39;&#34;{k}&#34;: {v}&#39; for k, v in v.items())
                else:
                    s += f&#34;{&#39;, &#39;.join(str(i) for i in v)}&#34;

                s += parentheses[v.__class__.__name__][1]
            else:
                s += str(v)

            s += &#34;, &#34;

        s = s[:-2] + &#34;)&#34;
        return s

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self.__repr__()

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Compare two objects.

        Args:
            other (any): object to compare

        Returns:
            bool
        &#34;&#34;&#34;
        if not isinstance(other, self.__class__):
            return False

        for k in self.__class_attributes__:
            if getattr(self, k) != getattr(other, k):
                return False

        return True

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Return the hash of the object.

        Returns:
            int
        &#34;&#34;&#34;
        ordered = sorted(self.__clean_dict__.items())
        return hash(tuple(ordered))

    def __contains__(self, item) -&gt; bool:
        &#34;&#34;&#34;Check if the object contains an item.

        This is used to check if an attribute exists via the \
        built-in `in` operator.

        Args:
            item (any): item to check

        Returns:
            bool
        &#34;&#34;&#34;
        return item in self.__clean_dict__.keys()

    def __iter__(self):
        &#34;&#34;&#34;Return an iterator for the object.

        Returns:
            iterator
        &#34;&#34;&#34;
        return iter(self.__clean_dict__.items())

    @property
    def __class_attributes__(self) -&gt; dict[str, type]:
        &#34;&#34;&#34;Return all the attributes of the class and their type.

        Returns:
            dict
        &#34;&#34;&#34;
        return {
            k: v if isinstance(v, type) else None
            for k, v in self.__class__.__annotations__.items()
            if not k.startswith(&#34;_&#34;)
        }

    @property
    def __clean_dict__(self) -&gt; dict:
        &#34;&#34;&#34;Return a dictionary with all the attributes of the object, \
            except for the ones starting with an underscore (private).

        Returns:
            dict
        &#34;&#34;&#34;
        return {k: v for k, v in self.__dict__.items() if not k.startswith(&#34;_&#34;)}

    def _importDecorator(f, *_, **__) -&gt; None:
        &#34;&#34;&#34;Import the correct serializer for the function.

        The serializer will be put in the `_serializer` attribute of the object.
        It&#39;s mandatory to have all the functions decorated with this decorator \
        to contain the name of the serializer in their name.

        Unittest will require all the serializers to be installed.

        Args:
            f (function): function to decorate

        Raises:
            ImportError: Could not import the correct serializer
        &#34;&#34;&#34;
        libs = {
            &#34;json&#34;: &#34;json&#34;,  # could be ujson but json is in the stdlib
            &#34;yaml&#34;: &#34;PyYAML&#34;,  # not in the stdlib
            &#34;toml&#34;: &#34;toml&#34;,  # not in the stdlib
        }
        serializer = None

        for k, v in libs.items():
            if k in f.__name__:
                serializer = importlib.import_module(k)
                break

        if serializer is None:
            raise ImportError(
                &#34;Could not import the correct serializer for the function &#34;
                f&#34;{f.__name__}.&#34;
                f&#34; Please install the required library {v}.&#34;
            )

        def wrapper(self: Dataclass, *args, **kwargs):
            self._serializer = serializer
            return f(self, *args, **kwargs)

        return wrapper

    @property
    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;Return a dictionary with all the attributes of the object.

        Returns:
            dict
        &#34;&#34;&#34;

        def iterable_type(var: any) -&gt; type:
            if isinstance(var, (list, tuple, set)):
                return var.__class__

            return None

        d = {}

        for k, v in self.__clean_dict__.items():
            if t := iterable_type(v):
                # handle recursive lists
                d[k] = t(i.to_dict if isinstance(i, Dataclass) else i for i in v)
            elif isinstance(v, Dataclass):
                # handle recursive dataclasses
                d[k] = v.to_dict
            else:
                # simple types
                d[k] = v

        return d

    @property
    @_importDecorator
    def to_json(self) -&gt; str:
        &#34;&#34;&#34;
        Return a json representation of the object. \
        Attributes are recursively converted to json.

        Returns:
            str
        &#34;&#34;&#34;
        dict_data = self.to_dict

        # all the sets and tuples are converted to lists
        # because json doesn&#39;t support them
        for k, v in dict_data.items():
            if isinstance(v, (set, tuple)):
                dict_data[k] = list(v)

        return self._serializer.dumps(dict_data)

    @property
    def to_json_pretty(self) -&gt; str:
        &#34;&#34;&#34;Return a pretty json representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self._serializer.dumps(self._serializer.loads(self.to_json), indent=4)

    @property
    @_importDecorator
    def to_toml(self) -&gt; str:
        &#34;&#34;&#34;Return a toml representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self._serializer.dumps(self.to_dict)

    @property
    @_importDecorator
    def to_yaml(self) -&gt; str:
        &#34;&#34;&#34;Return a yaml representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self._serializer.dump(self.to_dict)

    @property
    def attributes(self) -&gt; list:
        &#34;&#34;&#34;Return a list of all the attributes of the class.

        Returns:
            list
        &#34;&#34;&#34;
        return list(self.__class_attributes__.keys())

    @classmethod
    @_importDecorator
    def from_json(cls, json_string: str):
        &#34;&#34;&#34;Create an object from a json string.

        Args:
            json_string (str): json string

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(**cls._serializer.loads(json_string))

    @classmethod
    @_importDecorator
    def from_toml(cls, toml_string: str):
        &#34;&#34;&#34;Create an object from a toml string.

        Args:
            toml_string (str): toml string

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(**cls._serializer.loads(toml_string))

    @classmethod
    @_importDecorator
    def from_yaml(cls, yaml_string: str):
        &#34;&#34;&#34;Create an object from a yaml string.

        Args:
            yaml_string (str): yaml string

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(
            **cls._serializer.load(yaml_string, Loader=cls._serializer.FullLoader)
        )

    @classmethod
    def from_dict(cls, d: dict):
        &#34;&#34;&#34;Create an object from a dictionary.

        Args:
            d (dict): dictionary

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(**d)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="customdataclass.Dataclass"><code class="flex name class">
<span>class <span class="ident">Dataclass</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Custom dataclass.</p>
<p>The real reason is that I didn't really like the way dataclasses work,
and I wanted to have a better control over the attributes.</p>
<p>Instead of using the decorator, the a Dataclass must be initialized
by inheriting from it and specifying the attributes in the class definition.</p>
<p>This simplifies the code, allowing a better control over the attributes
and the methods.</p>
<p>Check the examples folder for more information.</p>
<p>Initialization parameters:
enforce_types (bool, optional): If True, the types of the attributes
are enforced. Defaults to True.
frozen (bool, optional): If True, attributes cannot be changed after
initialization. Defaults to True
partial (bool, optional): If True, parameters can be missing in the
initialization. Defaults to False.</p>
<p>Create a new Dataclass.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AttributeError</code></dt>
<dd>an invalid attribute is passed</dd>
<dt><code>AttributeError</code></dt>
<dd>an attribute is missing in kwargs.</dd>
<dt><code>TypeError</code></dt>
<dd>a value is not of the correct type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Dataclass:
    &#34;&#34;&#34;Custom dataclass.

    The real reason is that I didn&#39;t really like the way dataclasses work,
    and I wanted to have a better control over the attributes.

    Instead of using the decorator, the a Dataclass must be initialized
    by inheriting from it and specifying the attributes in the class definition.

    This simplifies the code, allowing a better control over the attributes
    and the methods.

    Check the examples folder for more information.

    Initialization parameters:
        enforce_types (bool, optional): If True, the types of the attributes \
            are enforced. Defaults to True.
        frozen (bool, optional): If True, attributes cannot be changed after \
            initialization. Defaults to True
        partial (bool, optional): If True, parameters can be missing in the \
            initialization. Defaults to False.
    &#34;&#34;&#34;

    _frozen: bool = False
    _frozen_after_init: bool = True
    _enforce_types: bool = True
    _partial = False
    _deserialized: bool = False
    _serializer: __module__ = None

    def __init__(self, **kwargs) -&gt; Dataclass:
        &#34;&#34;&#34;Create a new Dataclass.

        Raises:
            AttributeError: an invalid attribute is passed
            AttributeError: an attribute is missing in kwargs.
            TypeError: a value is not of the correct type.
        &#34;&#34;&#34;
        if not kwargs:
            return

        # unfreeze the class for the initialisation
        self._frozen = False

        # check if all the attributes are valid
        self._checkAttributesValid(kwargs)

        if not self._partial:
            # fix the default values
            self._fixDefaultValues(kwargs)
            # check if all the attributes are present
            self._checkAttributesPresent(kwargs)

        # fix the types
        self._fixMissingTypes()

        for k, v in self.__class_attributes__.items():
            # skip the loop if partial is True and the attribute is not present
            if self._enforce_types and not (self._partial and k not in kwargs):
                # serialized format don&#39;t support tuple and set (they convert \
                # both to list), so we need to convert them back IMPLICITLY
                if self._checkDeserializedIterator(kwargs[k], v):
                    if self._deserialized:
                        # convert to tuple or set
                        kwargs[k] = v(kwargs[k])

                # serialised format don&#39;t support classes (they convert them to \
                # dict), so we need to convert them back IMPLICITLY
                if self._checkDeserializedClass(kwargs[k], v):
                    # convert to class
                    if self._deserialized:
                        # convert to class
                        kwargs[k] = v.from_dict(kwargs[k])

                # check that the type is correct
                if not self._checkTypeCorrect(kwargs[k], v):
                    raise TypeError(f&#34;{k} should be {v}, not {type(kwargs[k])}&#34;)

            setattr(self, k, kwargs.get(k, None))

        # freeze the class
        self._frozen = self._frozen_after_init
        # unset the deserialized flag
        self._deserialized = False

    def _checkAttributesValid(self, kwargs: dict) -&gt; bool:
        &#34;&#34;&#34;Check if all the attributes are valid (as specified in the class \
            definition).

        Args:
            kwargs (dict): kwargs to check

        Returns:
            bool: True if all the attributes are valid, False otherwise.
        &#34;&#34;&#34;
        for k in kwargs.keys():
            if k not in self.__class_attributes__.keys():
                raise AttributeError(f&#34;{k} is not a valid attribute&#34;)

        return True

    def _fixDefaultValues(self, kwargs: dict) -&gt; None:
        &#34;&#34;&#34;Fix the default values.

        Args:
            kwargs (dict): kwargs to check
        &#34;&#34;&#34;
        for k in self.__class_attributes__:
            if k not in kwargs:
                kwargs[k] = self.__getattribute__(k)

    def _checkAttributesPresent(self, kwargs: dict) -&gt; bool:
        &#34;&#34;&#34;Check if all the attributes are present (as specified in the class \
            definition).

        Args:
            kwargs (dict): kwargs to check

        Returns:
            bool: True if all the attributes are present, False otherwise.
        &#34;&#34;&#34;
        for k in self.__class_attributes__.keys():
            if k not in kwargs:
                raise AttributeError(f&#34;Missing {k} in kwargs&#34;)

        return True

    def _fixMissingTypes(self) -&gt; None:
        &#34;&#34;&#34;Fix the missing types.&#34;&#34;&#34;
        for k, v in self.__class_attributes__.items():
            if v is None:
                # no type has been specified
                self.__class__.__annotations__[k] = Any

    def _checkTypeCorrect(self, value: Any, valid_type: type) -&gt; bool:
        &#34;&#34;&#34;Check if the type of the value is correct.

        Args:
            value (Any): value to check
            valid_type (type): type of the value

        Returns:
            bool: True if the type is correct, False otherwise.
        &#34;&#34;&#34;
        if valid_type in (Any, None):
            return True

        return isinstance(value, valid_type)

    def _checkDeserializedIterator(self, value: list[Any], valid_type: type) -&gt; bool:
        &#34;&#34;&#34;Check if the value is a valid iterator.

        Args:
            value (list[Any]): value to check
            valid_type (type): type of the value

        Returns:
            bool: True if the value is valid, False otherwise.
        &#34;&#34;&#34;
        if not isinstance(value, list):
            return False

        return valid_type in (set, tuple)

    def _checkDeserializedClass(self, value: dict, valid_type: type) -&gt; bool:
        &#34;&#34;&#34;Check if the value is a valid class.

        Args:
            value (dict): value to check
            valid_type (type): type of the value

        Returns:
            bool: True if the value is valid, False otherwise.
        &#34;&#34;&#34;
        if not isinstance(value, dict):
            return False

        return issubclass(valid_type, Dataclass)

    def __init_subclass__(
        cls,
        enforce_types: bool = True,
        frozen: bool = True,
        partial: bool = False,
        **kwargs,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the subclass.

        Args:
            enforce_types (bool, optional): If True, the types of the attributes \
                are enforced.
            frozen (bool, optional): If True, attributes cannot be changed after \
                initialization. Defaults to True.
            partial (bool, optional): If True, the class can be initialized with \
                missing attributes. Defaults to False.
        &#34;&#34;&#34;
        cls._enforce_types = enforce_types
        cls._frozen_after_init = frozen
        cls._partial = partial
        super().__init_subclass__(**kwargs)

    def __setattr__(self, key: str, value):
        &#34;&#34;&#34;Set an attribute.

        Args:
            key (str): name of the attribute
            value (any): value of the attribute

        Raises:
            AttributeError: Attribute is not valid
        &#34;&#34;&#34;
        if key.startswith(&#34;_&#34;):
            super().__setattr__(key, value)
            return

        if self._frozen:
            raise AttributeError(
                f&#34;Can&#39;t set {key}. {self.__class__.__name__} is immutable.&#34;
            )

        super().__setattr__(key, value)

    def __repr__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        if not self.__clean_dict__:
            return f&#34;{self.__class__.__name__}()&#34;

        parentheses = {
            &#34;tuple&#34;: (&#34;(&#34;, &#34;)&#34;),
            &#34;list&#34;: (&#34;[&#34;, &#34;]&#34;),
            &#34;set&#34;: (&#34;{&#34;, &#34;}&#34;),
            &#34;dict&#34;: (&#34;{&#34;, &#34;}&#34;),
        }

        s = f&#34;{self.__class__.__name__}(&#34;

        for k, v in self.__clean_dict__.items():
            if self._partial and v is None:
                continue
            s += f&#34;{k}=&#34;
            if isinstance(v, str):
                s += f&#39;&#34;{v}&#34;&#39;
            elif isinstance(v, (list, tuple, set, dict)):
                s += parentheses[v.__class__.__name__][0]
                if isinstance(v, dict):
                    s += &#34;, &#34;.join(f&#39;&#34;{k}&#34;: {v}&#39; for k, v in v.items())
                else:
                    s += f&#34;{&#39;, &#39;.join(str(i) for i in v)}&#34;

                s += parentheses[v.__class__.__name__][1]
            else:
                s += str(v)

            s += &#34;, &#34;

        s = s[:-2] + &#34;)&#34;
        return s

    def __str__(self) -&gt; str:
        &#34;&#34;&#34;Return a string representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self.__repr__()

    def __eq__(self, other) -&gt; bool:
        &#34;&#34;&#34;Compare two objects.

        Args:
            other (any): object to compare

        Returns:
            bool
        &#34;&#34;&#34;
        if not isinstance(other, self.__class__):
            return False

        for k in self.__class_attributes__:
            if getattr(self, k) != getattr(other, k):
                return False

        return True

    def __hash__(self) -&gt; int:
        &#34;&#34;&#34;Return the hash of the object.

        Returns:
            int
        &#34;&#34;&#34;
        ordered = sorted(self.__clean_dict__.items())
        return hash(tuple(ordered))

    def __contains__(self, item) -&gt; bool:
        &#34;&#34;&#34;Check if the object contains an item.

        This is used to check if an attribute exists via the \
        built-in `in` operator.

        Args:
            item (any): item to check

        Returns:
            bool
        &#34;&#34;&#34;
        return item in self.__clean_dict__.keys()

    def __iter__(self):
        &#34;&#34;&#34;Return an iterator for the object.

        Returns:
            iterator
        &#34;&#34;&#34;
        return iter(self.__clean_dict__.items())

    @property
    def __class_attributes__(self) -&gt; dict[str, type]:
        &#34;&#34;&#34;Return all the attributes of the class and their type.

        Returns:
            dict
        &#34;&#34;&#34;
        return {
            k: v if isinstance(v, type) else None
            for k, v in self.__class__.__annotations__.items()
            if not k.startswith(&#34;_&#34;)
        }

    @property
    def __clean_dict__(self) -&gt; dict:
        &#34;&#34;&#34;Return a dictionary with all the attributes of the object, \
            except for the ones starting with an underscore (private).

        Returns:
            dict
        &#34;&#34;&#34;
        return {k: v for k, v in self.__dict__.items() if not k.startswith(&#34;_&#34;)}

    def _importDecorator(f, *_, **__) -&gt; None:
        &#34;&#34;&#34;Import the correct serializer for the function.

        The serializer will be put in the `_serializer` attribute of the object.
        It&#39;s mandatory to have all the functions decorated with this decorator \
        to contain the name of the serializer in their name.

        Unittest will require all the serializers to be installed.

        Args:
            f (function): function to decorate

        Raises:
            ImportError: Could not import the correct serializer
        &#34;&#34;&#34;
        libs = {
            &#34;json&#34;: &#34;json&#34;,  # could be ujson but json is in the stdlib
            &#34;yaml&#34;: &#34;PyYAML&#34;,  # not in the stdlib
            &#34;toml&#34;: &#34;toml&#34;,  # not in the stdlib
        }
        serializer = None

        for k, v in libs.items():
            if k in f.__name__:
                serializer = importlib.import_module(k)
                break

        if serializer is None:
            raise ImportError(
                &#34;Could not import the correct serializer for the function &#34;
                f&#34;{f.__name__}.&#34;
                f&#34; Please install the required library {v}.&#34;
            )

        def wrapper(self: Dataclass, *args, **kwargs):
            self._serializer = serializer
            return f(self, *args, **kwargs)

        return wrapper

    @property
    def to_dict(self) -&gt; dict:
        &#34;&#34;&#34;Return a dictionary with all the attributes of the object.

        Returns:
            dict
        &#34;&#34;&#34;

        def iterable_type(var: any) -&gt; type:
            if isinstance(var, (list, tuple, set)):
                return var.__class__

            return None

        d = {}

        for k, v in self.__clean_dict__.items():
            if t := iterable_type(v):
                # handle recursive lists
                d[k] = t(i.to_dict if isinstance(i, Dataclass) else i for i in v)
            elif isinstance(v, Dataclass):
                # handle recursive dataclasses
                d[k] = v.to_dict
            else:
                # simple types
                d[k] = v

        return d

    @property
    @_importDecorator
    def to_json(self) -&gt; str:
        &#34;&#34;&#34;
        Return a json representation of the object. \
        Attributes are recursively converted to json.

        Returns:
            str
        &#34;&#34;&#34;
        dict_data = self.to_dict

        # all the sets and tuples are converted to lists
        # because json doesn&#39;t support them
        for k, v in dict_data.items():
            if isinstance(v, (set, tuple)):
                dict_data[k] = list(v)

        return self._serializer.dumps(dict_data)

    @property
    def to_json_pretty(self) -&gt; str:
        &#34;&#34;&#34;Return a pretty json representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self._serializer.dumps(self._serializer.loads(self.to_json), indent=4)

    @property
    @_importDecorator
    def to_toml(self) -&gt; str:
        &#34;&#34;&#34;Return a toml representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self._serializer.dumps(self.to_dict)

    @property
    @_importDecorator
    def to_yaml(self) -&gt; str:
        &#34;&#34;&#34;Return a yaml representation of the object.

        Returns:
            str
        &#34;&#34;&#34;
        return self._serializer.dump(self.to_dict)

    @property
    def attributes(self) -&gt; list:
        &#34;&#34;&#34;Return a list of all the attributes of the class.

        Returns:
            list
        &#34;&#34;&#34;
        return list(self.__class_attributes__.keys())

    @classmethod
    @_importDecorator
    def from_json(cls, json_string: str):
        &#34;&#34;&#34;Create an object from a json string.

        Args:
            json_string (str): json string

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(**cls._serializer.loads(json_string))

    @classmethod
    @_importDecorator
    def from_toml(cls, toml_string: str):
        &#34;&#34;&#34;Create an object from a toml string.

        Args:
            toml_string (str): toml string

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(**cls._serializer.loads(toml_string))

    @classmethod
    @_importDecorator
    def from_yaml(cls, yaml_string: str):
        &#34;&#34;&#34;Create an object from a yaml string.

        Args:
            yaml_string (str): yaml string

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(
            **cls._serializer.load(yaml_string, Loader=cls._serializer.FullLoader)
        )

    @classmethod
    def from_dict(cls, d: dict):
        &#34;&#34;&#34;Create an object from a dictionary.

        Args:
            d (dict): dictionary

        Returns:
            object
        &#34;&#34;&#34;
        cls._deserialized = True
        return cls(**d)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="customdataclass.Dataclass.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>d: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an object from a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>d</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dict(cls, d: dict):
    &#34;&#34;&#34;Create an object from a dictionary.

    Args:
        d (dict): dictionary

    Returns:
        object
    &#34;&#34;&#34;
    cls._deserialized = True
    return cls(**d)</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self: Dataclass, *args, **kwargs):
    self._serializer = serializer
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.from_toml"><code class="name flex">
<span>def <span class="ident">from_toml</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self: Dataclass, *args, **kwargs):
    self._serializer = serializer
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.from_yaml"><code class="name flex">
<span>def <span class="ident">from_yaml</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self: Dataclass, *args, **kwargs):
    self._serializer = serializer
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="customdataclass.Dataclass.attributes"><code class="name">var <span class="ident">attributes</span> : list</code></dt>
<dd>
<div class="desc"><p>Return a list of all the attributes of the class.</p>
<h2 id="returns">Returns</h2>
<p>list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def attributes(self) -&gt; list:
    &#34;&#34;&#34;Return a list of all the attributes of the class.

    Returns:
        list
    &#34;&#34;&#34;
    return list(self.__class_attributes__.keys())</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.to_dict"><code class="name">var <span class="ident">to_dict</span> : dict</code></dt>
<dd>
<div class="desc"><p>Return a dictionary with all the attributes of the object.</p>
<h2 id="returns">Returns</h2>
<p>dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_dict(self) -&gt; dict:
    &#34;&#34;&#34;Return a dictionary with all the attributes of the object.

    Returns:
        dict
    &#34;&#34;&#34;

    def iterable_type(var: any) -&gt; type:
        if isinstance(var, (list, tuple, set)):
            return var.__class__

        return None

    d = {}

    for k, v in self.__clean_dict__.items():
        if t := iterable_type(v):
            # handle recursive lists
            d[k] = t(i.to_dict if isinstance(i, Dataclass) else i for i in v)
        elif isinstance(v, Dataclass):
            # handle recursive dataclasses
            d[k] = v.to_dict
        else:
            # simple types
            d[k] = v

    return d</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.to_json"><code class="name">var <span class="ident">to_json</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self: Dataclass, *args, **kwargs):
    self._serializer = serializer
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.to_json_pretty"><code class="name">var <span class="ident">to_json_pretty</span> : str</code></dt>
<dd>
<div class="desc"><p>Return a pretty json representation of the object.</p>
<h2 id="returns">Returns</h2>
<p>str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_json_pretty(self) -&gt; str:
    &#34;&#34;&#34;Return a pretty json representation of the object.

    Returns:
        str
    &#34;&#34;&#34;
    return self._serializer.dumps(self._serializer.loads(self.to_json), indent=4)</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.to_toml"><code class="name">var <span class="ident">to_toml</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self: Dataclass, *args, **kwargs):
    self._serializer = serializer
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="customdataclass.Dataclass.to_yaml"><code class="name">var <span class="ident">to_yaml</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(self: Dataclass, *args, **kwargs):
    self._serializer = serializer
    return f(self, *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="customdataclass.Dataclass" href="#customdataclass.Dataclass">Dataclass</a></code></h4>
<ul class="two-column">
<li><code><a title="customdataclass.Dataclass.attributes" href="#customdataclass.Dataclass.attributes">attributes</a></code></li>
<li><code><a title="customdataclass.Dataclass.from_dict" href="#customdataclass.Dataclass.from_dict">from_dict</a></code></li>
<li><code><a title="customdataclass.Dataclass.from_json" href="#customdataclass.Dataclass.from_json">from_json</a></code></li>
<li><code><a title="customdataclass.Dataclass.from_toml" href="#customdataclass.Dataclass.from_toml">from_toml</a></code></li>
<li><code><a title="customdataclass.Dataclass.from_yaml" href="#customdataclass.Dataclass.from_yaml">from_yaml</a></code></li>
<li><code><a title="customdataclass.Dataclass.to_dict" href="#customdataclass.Dataclass.to_dict">to_dict</a></code></li>
<li><code><a title="customdataclass.Dataclass.to_json" href="#customdataclass.Dataclass.to_json">to_json</a></code></li>
<li><code><a title="customdataclass.Dataclass.to_json_pretty" href="#customdataclass.Dataclass.to_json_pretty">to_json_pretty</a></code></li>
<li><code><a title="customdataclass.Dataclass.to_toml" href="#customdataclass.Dataclass.to_toml">to_toml</a></code></li>
<li><code><a title="customdataclass.Dataclass.to_yaml" href="#customdataclass.Dataclass.to_yaml">to_yaml</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>